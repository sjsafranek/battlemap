<!DOCTYPE html>
<html>
    <head>

    	<title>CRS.Simple example - Leaflet</title>

    	<meta charset="utf-8" />
    	<meta name="viewport" content="width=device-width, initial-scale=1.0">

    	<link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />

        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==" crossorigin=""/>
        <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js" integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew==" crossorigin=""></script>

        <!-- https://github.com/Sumbera/gLayers.Leaflet/blob/master/L.CanvasLayer.js -->
        <script src="https://cdn.jsdelivr.net/gh/Sumbera/gLayers.Leaflet/L.CanvasLayer.js"></script>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    	<style>


            body {
                padding: 0;
                margin: 0;
            }

            html,
            body,
            #map
            {
                height: 100%;
                width: 100%;
            }

            .controls {
                background-color: #fff;
                border-bottom: 1px solid #ccc;
                border-radius: 4px;
                padding: 4px 6px;
            }

            /*#drawCanvas {
                background: transparent;
                position: absolute;
            }
            }*/

            /*.controls {
                position:absolute;
                top: 8px;
                right: 8px;
                background-color:#2277dd;
                padding: 5px;
                margin: 2px;
                color: #fff;
                -webkit-border-radius: 4px;
                border-radius: 4px;
            }*/



    	</style>

    </head>
    <body>

        <div id='map'></div>

        <script>


/*
            // by Chtiwi Malek
            // http://www.codicode.com
            function enableDraw() {
                let mousePressed = false;
                let lastX, lastY;

                let canvas = document.getElementById('drawCanvas');
                let context = canvas.getContext('2d')
                canvas.width = $(window).width();
                canvas.height = 1000;

                $(canvas).mousedown(function (e) {
                    mousePressed = true;
                    Draw(e.pageX, e.pageY, false);
                });

                $(canvas).mousemove(function (e) {
                    if (mousePressed) {
                        Draw(e.pageX , e.pageY , true);
                    }
                });

                $(canvas).mouseup(function (e) {
                    mousePressed = false;
                });

                $(canvas).mouseleave(function (e) {
                    mousePressed = false;
                });

                function Draw(x, y, isDown) {
                    if (isDown) {
                        context.beginPath();
                        context.strokeStyle = $('#selColor').val();
                        context.lineWidth = $('#selWidth').val();
                        context.lineJoin = "round";
                        context.moveTo(lastX, lastY);
                        context.lineTo(x, y);
                        context.closePath();
                        context.stroke();
                    }
                    lastX = x; lastY = y;
                }

                $("#clearDrawCanvas").on('click', function(e) {
                    context.setTransform(1, 0, 0, 1, 0, 0);
                    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
                });
            }
*/





function preventPropogation(obj, map) {
	// http://gis.stackexchange.com/questions/104507/disable-panning-dragging-on-leaflet-map-for-div-within-map
	// Disable dragging when user's cursor enters the element
	if(obj.getContainer != undefined){
		obj = obj.getContainer();
	}

	if(obj.get != undefined){
		obj = obj.get(0);
	}

	// fixed non-passive event warning
	// https://stackoverflow.com/questions/52309356/overlay-div-over-leaflet-and-stop-mouse-action-propagation
	// https://github.com/Leaflet/Leaflet/pull/6694
	L.DomEvent.disableScrollPropagation(obj);
	L.DomEvent.disableClickPropagation(obj);

	// Touch screens
	obj.addEventListener('touchstart', function (e) {
		if(map.getContainer() == e.fromElement){
			return;
		}
		if(e.buttons > 0){
			return;
		}
		map.dragging.disable();
	}, {passive: true});

	obj.addEventListener('touchend', function (e) {
		map.dragging.enable();
	}, {passive: true});
}


            // http://bl.ocks.org/jdarling/06019d16cb5fd6795edf
            var randomColor = (function(){
                var golden_ratio_conjugate = 0.618033988749895;
                var h = Math.random();

                var hslToRgb = function (h, s, l){
                    var r, g, b;

                    if(s == 0){
                        r = g = b = l; // achromatic
                    }
                    else {
                        function hue2rgb(p, q, t){
                            if(t < 0) t += 1;
                            if(t > 1) t -= 1;
                            if(t < 1/6) return p + (q - p) * 6 * t;
                            if(t < 1/2) return q;
                            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                            return p;
                        }

                        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        var p = 2 * l - q;
                        r = hue2rgb(p, q, h + 1/3);
                        g = hue2rgb(p, q, h);
                        b = hue2rgb(p, q, h - 1/3);
                    }

                    return '#'+Math.round(r * 255).toString(16)+Math.round(g * 255).toString(16)+Math.round(b * 255).toString(16);
                };

                return function(){
                    h += golden_ratio_conjugate;
                    h %= 1;
                    return hslToRgb(h, 0.5, 0.60);
                };
            })();




            function enableFileDrop($elem, callback) {
            	$elem.get(0).ondrop = function(e) {
            		e.preventDefault();
            		$(this).css('outline', 'none');
            		var file = e.dataTransfer.files[0];
            		callback && callback(file);
            	}
            	$elem.get(0).ondragover = $elem.get(0).ondragenter = function(e) {
            		e.preventDefault();
            		$(this).css('outline', '2px dashed #92b0b3');
            	};
            	$elem.get(0).ondragstart = function(e) {
            		e.preventDefault();
            		$(this).css('outline', '2px dashed #92b0b3');
            	};
            	$elem.get(0).ondragend = $elem.get(0).ondragleave = function(e) {
            		e.preventDefault();
            		$(this).css('outline', 'none');
            	};
            }



            var App = function(mapId) {
                var self = this;

                this._drawing = false;

                // resources
                this.elements = {
                    $cellSizeInput: $('<input>', {
                            id: 'cellSize',
                            type: 'number',
                            min: 5,
                            max: 1000,
                            value: 100
                        })
                        .on('change', function(e) {
                            self.onCellSizeChange(e);
                        }),

                    $fileUploadInput: $('<input>', {
                            type: 'file',
                            accept: 'image/png, image/jpeg'
                        })
                        .on('change', function(e) {
                            self.onFileUpload(this.files[0]);
                        }),

                    $enableDrawModeInput: $('<input>', {
                            type: 'checkbox'
                        })
                        .on('change', function(e) {
                            $(this).is(':checked') ?
                                self.enableDraw() : self.disableDraw();
                        })
                };

                // container for layers
                this.layers = {
                    imageLayer: null,
                    gridLayer: null
                };

                // initialize map
            	this.map = L.map(mapId, {
            		crs: L.CRS.Simple,
                    minZoom: -5
            	});

            	this.map.fitBounds([[0,0], [1000,1000]]);

                this.map.on('contextmenu', function(e) {
                    self.addMarker(e);
                });



                // drawing
                this.drawLayer = L.canvasLayer()
                    .delegate(this) // -- if we do not inherit from L.CanvasLayer we can setup a delegate to receive events from L.CanvasLayer
                    .addTo(this.map);

                this._mouseDown = false;
                this.drawFeatures = [
                    {
                       lineWidth: 2,
                       strokeStyle: 'black',
                       path: []
                   }
                ];

                this.map.on('mousedown', function(e) {
                    if (self._drawing) {
                        self._mouseDown = true;
                    }
                });

                this.map.on('mouseup', function(e) {
                    if (self._drawing) {
                        self._mouseDown = false;
                        self.drawFeatures.push({
                            lineWidth: 2,
                            strokeStyle: 'black',
                            path: []
                        });
                    }
                });

                this.map.on('mousemove', function(e) {
                    if (self._drawing && self._mouseDown) {
                        self.drawFeatures[self.drawFeatures.length-1].path.push(e.latlng);
                        self.drawLayer.drawLayer();
                    }
                });

                this.onDrawLayer = function(info) {
                    var ctx = info.canvas.getContext('2d');
                    ctx.clearRect(0, 0, info.canvas.width, info.canvas.height);
                    ctx.fillStyle = "rgba(255,116,0, 0.2)";
                    for (var i = 0; i < self.drawFeatures.length; i++) {

                        let last = null;
                        ctx.beginPath();
                        ctx.strokeStyle = self.drawFeatures[i].strokeStyle;
                        ctx.lineWidth = self.drawFeatures[i].lineWidth;
                        ctx.lineJoin = "round";

                        for (var j=0; j<self.drawFeatures[i].path.length; j++) {
                            var d = self.drawFeatures[i].path[j];
                            if (info.bounds.contains(d)) {
                                var dot = info.layer._map.latLngToContainerPoint(d);
                                if (last) {
                                    ctx.moveTo(last.x, last.y);
                                    ctx.lineTo(dot.x, dot.y);
                                }
                                last = dot;
                            }
                            else {
                                last = null;
                            }
                        }

                        // ctx.closePath();
                        ctx.stroke();

                    }
                };
                //.end





                // initialize controls
                this.controls = L.control({position: 'topright'});
                this.controls.onAdd = function(map) {
                    return $('<div>')
                        .addClass('leaflet-control controls')
                        .append(
                            $('<div>').append(
                                self.elements.$fileUploadInput
                            ),
                            $('<div>').append(
                                'Grid size (pixels) ',
                                self.elements.$cellSizeInput
                            ),
                            $('<div>').append(
                                'Enable draw mode ',
                                self.elements.$enableDrawModeInput
                            )
                        )[0];
                };
                this.controls.addTo(this.map);
                preventPropogation(this.controls, this.map);

                enableFileDrop(
                    $(this.map._container),
                    function(file) {
                        self.onFileUpload(file);
                    }
                );

            }

            App.prototype.onFileUpload = function(file) {
                var self = this;

                // create file reader
                let reader = new FileReader();

                // parse file listener
                reader.onload = function(e) {
                    // create image
                    let img = new Image();
                    img.src = e.target.result;
                    // drawing of the test image - img1
                    img.onload = function () {
                        // load image onto map
                        var bounds = [[0,0], [img.height, img.width]];
                        var imageLayer = L.imageOverlay(e.target.result, bounds);
                        imageLayer.addTo(self.map);

                        // cleanup old layer
                        self.imageLayer && self.imageLayer.remove();

                        // add new layer                        //
                        self.imageLayer = imageLayer;

                        self.map.fitBounds(bounds);

                        // draw battle grid
                        self.drawGrid(bounds);
                    };
                }

                // read file
                reader.readAsDataURL(file);
            }

            App.prototype.onCellSizeChange = function(e) {
                if (!this.imageLayer) {
                    return;
                }
                var bbox = this.imageLayer.getBounds();
                this.drawGrid([
                    [bbox._southWest.lat, bbox._southWest.lng],
                    [bbox._northEast.lat, bbox._northEast.lng]
                ]);
            }

            App.prototype.drawGrid = function(bounds) {
                // cleanup old layer
                this.gridLayer && this.gridLayer.remove();

                let canvas = $('<canvas>')[0];
                let context = canvas.getContext('2d');
                canvas.height = bounds[1][0];
                canvas.width  = bounds[1][1];

                let s = parseInt(this.elements.$cellSizeInput.val());
                let nX = Math.floor(canvas.width / s) - 2;
                let nY = Math.floor(canvas.height / s) - 2;
                let pX = canvas.width - nX * s;
                let pY = canvas.height - nY * s;

                let pL = Math.ceil(pX / 2) - 0.5;
                let pT = Math.ceil(pY / 2) - 0.5;
                let pR = canvas.width - nX * s - pL;
                let pB = canvas.height - nY * s - pT;

                context.strokeStyle = 'black';
                context.lineWidth = 2;
                context.setLineDash([5, 3])
                context.beginPath();
                for (var x = pL; x <= canvas.width - pR; x += s) {
                    context.moveTo(x, pT);
                    context.lineTo(x, canvas.height - pB);
                }
                for (var y = pT; y <= canvas.height - pB; y += s) {
                    context.moveTo(pL, y);
                    context.lineTo(canvas.width - pR, y);
                }
                context.stroke();

                // cleanup old layer
                this.gridLayer && this.gridLayer.remove();
                var gridLayer = L.imageOverlay(canvas.toDataURL(), bounds);
                gridLayer.addTo(this.map);
                this.gridLayer = gridLayer;
            }

            App.prototype.addMarker = function(e) {
                this._count = this._count || 1;
                this._count++;

                var color = randomColor();
                const myCustomColour = color;

                const markerHtmlStyles = `
                    background-color: ${myCustomColour};
                    width: 2rem;
                    height: 2rem;
                    display: block;
                    left: -1.5rem;
                    top: -1.5rem;
                    position: relative;
                    border-radius: 3rem 3rem 0;
                    transform: rotate(45deg);
                    border: 1px solid #FFFFFF;
                `;

                const icon = L.divIcon({
                    className: "my-custom-pin",
                    iconAnchor: [0, 24],
                    labelAnchor: [-6, 0],
                    popupAnchor: [0, -36],
                    html: `<span style="${markerHtmlStyles}">`+this._count+`</span>`
                });

                let marker = L.marker(
                    e.latlng,
                    {
                        icon: icon,
                        draggable: true
                    });

                marker.on('contextmenu', function(e) {
                    e.originalEvent.stopPropagation();
                    this.remove();
                });

                marker.addTo(this.map);
            }

            App.prototype.enableDraw = function() {
                this._drawing = true;
                this.map.touchZoom.disable();
                this.map.doubleClickZoom.disable();
                this.map.scrollWheelZoom.disable();
                this.map.dragging.disable();
            }

            App.prototype.disableDraw = function() {
                this._drawing = false;
                this.map.touchZoom.enable();
                this.map.doubleClickZoom.enable();
                this.map.scrollWheelZoom.enable();
                this.map.dragging.enable();
            }

            var app = new App('map');




            // map.createPane('grid');
            // var pane = map.getPane('grid');
            // $(pane).append(
            //     $('<canvas>').attr('id', 'grid')
            // );







        </script>

    </body>
</html>
